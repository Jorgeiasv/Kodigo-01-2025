/*===============================================================
  LABORATORIO  "De OLTP a OLAP en Oracle"
  Versión: 2025-05-29
  Creador : Ing. Jorge Luis Iraheta Alvarenga
  Fecha   : 30/05/2025 12:19 am 
  Ramdon dato: estaba escuchado billete grande  JAJAJJA

===============================================================*/

-- ESQUEMA OLTP

CREATE USER oltp_user IDENTIFIED BY oltp_Agricola1$ QUOTA UNLIMITED ON users;
GRANT CONNECT, RESOURCE TO oltp_user;

ALTER SESSION SET CURRENT_SCHEMA = oltp_user;

-- PARA VALIDAR CON QUE USUARIO ESTAMOS ACCEDIENDO 

SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS current_schema
FROM   dual;


-- CREACION DE MODELO DE BASE DE DATOS.


CREATE TABLE clientes (
  cliente_id  NUMBER GENERATED BY DEFAULT AS IDENTITY,
  nombre      VARCHAR2(100),
  email       VARCHAR2(150) UNIQUE,
  fecha_alta  DATE,
  CONSTRAINT pk_clientes PRIMARY KEY(cliente_id)
);

CREATE TABLE productos (
  producto_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
  categoria   VARCHAR2(20),
  nombre      VARCHAR2(120),
  precio      NUMBER(10,2),
  stock       NUMBER,
  CONSTRAINT pk_productos PRIMARY KEY(producto_id)
);

CREATE TABLE pedidos (
  pedido_id    NUMBER GENERATED BY DEFAULT AS IDENTITY,
  cliente_id   NUMBER,
  fecha_pedido DATE,
  total        NUMBER(12,2),
  estado       VARCHAR2(20),
  CONSTRAINT pk_pedidos PRIMARY KEY(pedido_id),
  CONSTRAINT fk_ped_cli FOREIGN KEY(cliente_id)
            REFERENCES clientes(cliente_id)
);

CREATE TABLE pedido_detalle (
  pedido_id       NUMBER,
  producto_id     NUMBER,
  cantidad        NUMBER,
  precio_unitario NUMBER(10,2),
  CONSTRAINT pk_ped_det PRIMARY KEY(pedido_id,producto_id),
  CONSTRAINT fk_det_ped  FOREIGN KEY(pedido_id)
            REFERENCES pedidos(pedido_id),
  CONSTRAINT fk_det_prod FOREIGN KEY(producto_id)
            REFERENCES productos(producto_id)
);

CREATE TABLE pagos (
  pago_id    NUMBER GENERATED BY DEFAULT AS IDENTITY,
  pedido_id  NUMBER,
  fecha_pago DATE,
  metodo     VARCHAR2(20),
  monto      NUMBER(12,2),
  CONSTRAINT pk_pagos PRIMARY KEY(pago_id),
  CONSTRAINT fk_pagos_ped FOREIGN KEY(pedido_id)
            REFERENCES pedidos(pedido_id)
);

CREATE TABLE envios (
  envio_id       NUMBER GENERATED BY DEFAULT AS IDENTITY,
  pedido_id      NUMBER,
  fecha_envio    DATE,
  transportista  VARCHAR2(40),
  costo_envio    NUMBER(10,2),
  CONSTRAINT pk_envios PRIMARY KEY(envio_id),
  CONSTRAINT fk_env_ped FOREIGN KEY(pedido_id)
            REFERENCES pedidos(pedido_id)
);

-- ╔═══════════════════════════════════════════════════════════╗
-- ║ 2.  CARGA MASIVA EN OLTP                                  ║
-- ╚═══════════════════════════════════════════════════════════╝
DECLARE
  -- 395 días atrás desde la fecha actual del servidor
  v_start DATE := TRUNC(SYSDATE) - 395;   -- 30-abr-2024 si hoy es 29-may-2025
BEGIN
  -- CLIENTES (20 000 filas de ejemplo)
  FOR i IN 1 .. 20000 LOOP
    INSERT INTO clientes(nombre, email, fecha_alta)
    VALUES ('Cliente #' || i,
            'cliente' || i || '@demo.com',
            v_start + TRUNC(DBMS_RANDOM.VALUE(0, 395)));
  END LOOP;

  COMMIT;   -- Confirma los inserts
END;
/

-- Validadores de cargas.

Select * from clientes ;


BEGIN
  -- Insertar 3 000 productos de ejemplo
  FOR i IN 1 .. 3000 LOOP
    INSERT INTO productos (categoria, nombre, precio, stock)
    VALUES (
      CASE MOD(i, 5)
        WHEN 0 THEN 'Electrónica'
        WHEN 1 THEN 'Ropa'
        WHEN 2 THEN 'Hogar'
        WHEN 3 THEN 'Libros'
        ELSE       'Deportes'
      END,
      'Producto #' || i,
      ROUND(DBMS_RANDOM.VALUE(5, 500), 2),   -- precio entre 5 y 500
      TRUNC(DBMS_RANDOM.VALUE(0, 1000))      -- stock entre 0 y 999
    );
  END LOOP;

  COMMIT;   -- confirma las filas insertadas
END;
/

-- Validadores de cargas.

Select * from Productos ;

-- Llenado de las tablas 
-- tardo en ejecutarse : 316.58 Segundos

DECLARE
  ------------------------------------------------------------------
  -- 1. Colecciones con los IDs válidos de clientes y productos
  ------------------------------------------------------------------
  TYPE t_num_tbl IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  l_cli_ids  t_num_tbl;
  l_prod_ids t_num_tbl;

  ------------------------------------------------------------------
  --  Variables de trabajo
  ------------------------------------------------------------------
  v_start  DATE := TRUNC(SYSDATE) - 395;          -- 30-abr-2024
  v_pid    pedidos.pedido_id%TYPE;                -- ID del pedido
  v_total  NUMBER;                                -- total del pedido
  v_cli_id NUMBER;                                -- cliente elegido
  v_prod   NUMBER;                                -- producto elegido
  v_qty    NUMBER;                                -- cantidad
  v_price  productos.precio%TYPE;                 -- precio unitario
BEGIN
  ------------------------------------------------------------------
  --  Cargar en memoria los IDs existentes
  ------------------------------------------------------------------
  SELECT cliente_id  BULK COLLECT INTO l_cli_ids  FROM clientes;
  SELECT producto_id BULK COLLECT INTO l_prod_ids FROM productos;

  ------------------------------------------------------------------
  --  Generar los pedidos
  ------------------------------------------------------------------
  FOR i IN 1 .. 50000 LOOP
    --------------------------------------------------------------
    -- Insertar el pedido (cliente real al azar)
    --------------------------------------------------------------
    v_cli_id := l_cli_ids(TRUNC(DBMS_RANDOM.VALUE(1, l_cli_ids.COUNT + 1)));

    INSERT INTO pedidos (cliente_id, fecha_pedido, total, estado)
    VALUES ( v_cli_id,
             v_start + TRUNC(DBMS_RANDOM.VALUE(0, 395)),
             0,
             'CREADO')
    RETURNING pedido_id INTO v_pid;

    v_total := 0;

    --------------------------------------------------------------
    --  detalle — sin repetir producto
    --------------------------------------------------------------
    DECLARE
      TYPE t_set IS TABLE OF BOOLEAN INDEX BY PLS_INTEGER;
      chosen t_set;                               -- productos ya usados
    BEGIN
      FOR j IN 1 .. TRUNC(DBMS_RANDOM.VALUE(1, 5)) LOOP
        ----------------------------------------------------------
        -- 4.2.1 Elegir un producto no repetido
        ----------------------------------------------------------
        LOOP
          v_prod := l_prod_ids(TRUNC(DBMS_RANDOM.VALUE(1,
                                                       l_prod_ids.COUNT + 1)));
          EXIT WHEN NOT chosen.EXISTS(v_prod);    -- sale si no está repetido
        END LOOP;
        chosen(v_prod) := TRUE;                   -- lo marcamos como usado

        v_qty := TRUNC(DBMS_RANDOM.VALUE(1, 5));  -- cantidad 1-4

        SELECT precio
        INTO   v_price
        FROM   productos
        WHERE  producto_id = v_prod;

        INSERT INTO pedido_detalle (pedido_id,
                                    producto_id,
                                    cantidad,
                                    precio_unitario)
        VALUES (v_pid,
                v_prod,
                v_qty,
                v_price);

        v_total := v_total + v_qty * v_price;
      END LOOP;

      ------------------------------------------------------------
      -- 4.3 Actualizar el total del pedido
      ------------------------------------------------------------
      UPDATE pedidos
      SET    total = v_total
      WHERE  pedido_id = v_pid;
    END;
  END LOOP;

  COMMIT;                                         -- confirma la carga
END;
/





-- Índice B-tree en OLTP
-- creacion de indice sobre la base OLTP para poder 
CREATE INDEX idx_oltp_pedido_id ON pedidos(pedido_id);





-- Creacion de usuario de OLAP 
-- Creacion de dimensiones 
-- creacion de tabla de hechos.

CREATE USER olap_user IDENTIFIED BY olap_pwd QUOTA UNLIMITED ON users;
GRANT CONNECT, RESOURCE TO olap;

ALTER SESSION SET CURRENT_SCHEMA = olap_user;

-- PARA VALIDAR CON QUE USUARIO ESTAMOS ACCEDIENDO 

SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') AS current_schema
FROM   dual;


-- CREACION DE TECNICAS DE PARTICIONAMIENTO Y INDICES.


-- Dimensión PRODUCTO  con ejemplo de LIST 


CREATE TABLE dim_producto
PARTITION BY LIST (categoria)
( PARTITION p_elec  VALUES ('Electrónica')
, PARTITION p_ropa  VALUES ('Ropa')
, PARTITION p_hogar VALUES ('Hogar')
, PARTITION p_libro VALUES ('Libros')
, PARTITION p_other VALUES (DEFAULT)      -- captura 'Deportes' y extras
)
AS SELECT producto_id,categoria,nombre
   FROM oltp_user.productos;

-- Agregamos constrain   
ALTER TABLE dim_producto ADD CONSTRAINT pk_dim_prod PRIMARY KEY(producto_id);

-- DIMENSION DE CLIENTES 
CREATE TABLE dim_cliente
AS SELECT * FROM oltp_user.clientes;
ALTER TABLE dim_cliente ADD CONSTRAINT pk_dim_cli PRIMARY KEY(cliente_id);

-- DIMENSION DE FECHAS

CREATE TABLE dim_fecha (
  fecha_key   DATE PRIMARY KEY,
  anio        NUMBER,
  trimestre   NUMBER,
  mes         NUMBER,
  dia         NUMBER,
  dia_semana  VARCHAR2(9)
);

INSERT INTO dim_fecha
SELECT d,
       EXTRACT(YEAR FROM d),
       TO_NUMBER(TO_CHAR(d,'Q')),
       EXTRACT(MONTH FROM d),
       EXTRACT(DAY   FROM d),
       TO_CHAR(d,'DAY','NLS_DATE_LANGUAGE=SPANISH')
FROM (SELECT TO_DATE(:c_today,'YYYY-MM-DD') - 365 + LEVEL - 1 AS d
        FROM dual CONNECT BY LEVEL <= 365+180);

-- CREACION DE TABLA DE ECHO --> Ventas   con  RANGE &  HASH

CREATE TABLE fact_ventas
( fecha_key    DATE   NOT NULL
, cliente_id   NUMBER NOT NULL
, producto_id  NUMBER NOT NULL
, cantidad     NUMBER
, importe_neto NUMBER
, costo_envio  NUMBER
, CONSTRAINT fk_fact_fecha   FOREIGN KEY(fecha_key)
                             REFERENCES dim_fecha(fecha_key)
, CONSTRAINT fk_fact_cliente FOREIGN KEY(cliente_id)
                             REFERENCES dim_cliente(cliente_id)
, CONSTRAINT fk_fact_prod    FOREIGN KEY(producto_id)
                             REFERENCES dim_producto(producto_id)
)
PARTITION BY RANGE (fecha_key)
 SUBPARTITION BY HASH (cliente_id)
 SUBPARTITION TEMPLATE (SUBPARTITION h1, h2, h3, h4)
( PARTITION p_2024q2 VALUES LESS THAN (DATE '2024-07-01')
, PARTITION p_2024q3 VALUES LESS THAN (DATE '2024-10-01')
, PARTITION p_2024q4 VALUES LESS THAN (DATE '2025-01-01')
, PARTITION p_2025q1 VALUES LESS THAN (DATE '2025-04-01')
, PARTITION p_2025q2 VALUES LESS THAN (DATE '2025-07-01')
, PARTITION p_future VALUES LESS THAN (MAXVALUE)
);

-- Índices OLAP
CREATE BITMAP INDEX bmx_prod_categoria
  ON dim_producto(categoria);

CREATE INDEX idx_fact_fk
  ON fact_ventas(fecha_key,cliente_id,producto_id);



--  ETL de carga incial  (Este etl esta creado en sql pero existen maneras de realizalo con python que ese ejemplo lo veremos mas adelante.)

CREATE OR REPLACE PROCEDURE etl_carga_inicial IS
BEGIN
  INSERT /*+ PARALLEL */ INTO fact_ventas
  SELECT TRUNC(p.fecha_pedido),          -- fecha_key
         p.cliente_id,
         d.producto_id,
         d.cantidad,
         d.cantidad*d.precio_unitario,
         e.costo_envio
  FROM   oltp.pedidos         p
  JOIN   oltp.pedido_detalle  d ON d.pedido_id = p.pedido_id
  JOIN   oltp.envios          e ON e.pedido_id = p.pedido_id;

  COMMIT;
  DBMS_STATS.GATHER_TABLE_STATS('OLAP','FACT_VENTAS');
END;
/
EXEC etl_carga_inicial;



-- PROCESOS DE VERIFIACION RAPIDA.

SET SERVEROUTPUT ON
DECLARE
  v_cnt NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_cnt FROM fact_ventas;
  DBMS_OUTPUT.PUT_LINE('Fact_ventas cargadas = '||v_cnt);
END;
/

SELECT partition_name, num_rows
FROM   user_tab_partitions
WHERE  table_name = 'FACT_VENTAS'
ORDER  BY partition_position;

-- Ejemplo de pruning (debe tocar solo p_2024q4 particion definida arriba )

EXPLAIN PLAN FOR
SELECT SUM(importe_neto)
FROM   fact_ventas fv
JOIN   dim_producto dp
  ON   dp.producto_id = fv.producto_id
WHERE  fv.fecha_key BETWEEN DATE '2024-10-01' AND DATE '2024-12-31'
  AND  dp.categoria = 'Ropa';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);


/
